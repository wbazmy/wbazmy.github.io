---
layout: post
title: 泛型程序设计
date: 2021-10-14
tags: JavaSE基础
---
## 1. 基本概念
泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用，例如，一个ArrayList类可以聚集任何类型的对象。  
在Java增加泛型类之前，泛型程序设计使用继承实现的。ArrayList类维护一个Object引用的数组。这种方法有两个问题：
1. 当获取一个值时必须进行强制类型转换。
2. 可以向数组列表添加任何类对象，没有错误检查。

泛型提供了类型参数：

```java
ArrayList<String> file=new ArrayList<>();
```

这样编译器就可以利用这个信息，从而解决了上述两个问题。  
类型参数可以使得程序具有更好的可读性和安全性。  

## 2. 定义简单泛型类
一个泛型类就是具有一个或多个类型变量的类。例：

```java
public class PairTest {
    public static void main(String[] args) {
        String a = "zy";
        String b = "a";
        Pair<String> mm = new Pair<>(a, b); //用具体的类型替换类型变量就可以实例化泛型类型
        System.out.println(mm.getFirst());
        System.out.println(mm.getSecond());
    }

}

class Pair<T> { //还可以有多个类型变量，如<T,U>
    private T first;
    private T second;

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public T getSecond() {
        return second;
    }
}
```

Java泛型类与c++模版类的机制有本质的区别。
## 3. 泛型方法
还可以定义一个带有类型参数的简单方法。类型变量放在修饰符后面，返回类型前面。

```java
public static <U> String Test(U u) {
        String a = u.toString();
        return a;
    }
```

泛型方法可以定义在普通类中，也可以定义在泛型类中。  
调用泛型方法：

```java
String s=Pair.<Integer>Test(5);
s=Pair.Test(5); //大多数情况下可以推断出类型即可省略
System.out.println(s);
```

## 4. 类型变量的限定
有时类或方法需要对类型变量加以约束，例：

```java
public static <T extends Comparable> T min(T[] a)... 
```

上述代码将T限制为实现了Comparable接口的类。min方法只能被实现了Comparable接口的类调用。  
为什么使用extends：&lt;T extends BoundType&gt;表示T应该是绑定类型的子类型，T和绑定类型可以是类也可以是接口。  
一个类型变量可以有多个限定：

```java
T extends Comparable & Serializable
```

由于单继承原因，限定中至多有一个类，如果用一个类作为限定，它必须是限定列表中的第一个。但可以有多个限定接口。

## 5. 泛型代码和虚拟机
虚拟机没有泛型类型对象，所有对象都属于普通类。  
类型擦除：无论何时定义一个泛型类型，都自动提供了一个相应的原始类型（raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除（erased) 类型变量, 并替换为限定类型（无限定的变量用Object)。  
原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。例如，类Pair&lt;T&gt;中的类型变量没有显式的限定，因此，原始类型用Object替换T。  
当程序调用泛型方法时，如果擦除返回类型，编译器会插入强制类型转换。存取一个泛型域时也要插入强制类型转换。  
类型擦除也会出现在泛型方法中。为了防止类型擦除和多态发生冲突，编译器会在子类中生成一个桥方法：

```java
public void setSecond(Object second){setSecond((Date)second);} //用来替换public void setSecond(LocalDate second) 父类中含有方法public void setSecond(Object second){}
```

在虚拟机中，用参数类型和返回类型确定一个方法，因此编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能正确处理这一情况。  
桥方法示例：在一个方法覆盖另一个方法时可以指定一个更严格的返回类型。

```java
public class student implements Cloneable
{
    public student clone() throws CloneNotSupportedException{}
}
```

Object.clone和student.clone方法被说成具有协变的返回类型。合成的Object clone桥方法调用了新定义的方法。  
Java泛型转换总结：
1. 虚拟机没有泛型，只有普通类和方法。
2. 所有的类型参数都用它们的限定类型或Object替换
3. 桥方法被合成来保持多态。
4. 为保持类型安全性，必要时插入强制类型转换。

## 6. 约束与局限性
泛型的限制大都是由类型擦除引起的。
1. 不能使用基本类型实例化类型参数，因为类型擦除后含有Object类型的域，而Object不能存储int值。
2. 运行时类型查询只适用于原始类型，instanceof Pair&lt;String&gt;会报错，p=(Pair&lt;String&gt;) a会警告。
3. 不能创建参数化类型数组。原因：类型擦除后会使得插入其他类型的元素。不允许创建数组，但声明Pair&lt;String&gt;[]变量是合法的。

```java
Pair<String>[] table=new Pair<String>[10]; //error
```

4. 不能实例化类型变量。new T(),T.class都是非法的。
5. 不能构造泛型数组。T[] mm=new T[2];
6. 不能在静态域和方法中引用类型变量。
7. 不能抛出也不能捕获泛型类对象，泛型类不能扩展Throwable。在异常规范中可以使用类型变量。

```java
public static <T extends Throwable> void dowork(T t) throws T //OK
```

8. 要注意擦除后的冲突。要避免一个类同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。

## 7. 泛型类型的继承规则
Pair&lt;graduate&gt;并不是Pair&lt;student&gt;的子类，无论S与T有什么联系，通常，Pair&lt;S&gt;与Pair&lt;T&gt;都没有什么联系。  
永远可以将参数化类型转换为一个原始类型。但转换成原始类型后设置实例域的话会产生类型错误，因为失去了原先的类型参数信息。    
泛型类可以扩展或实现其他的泛型类，例如ArrayList&lt;T&gt;类实现了List&lt;T&gt;接口。  
## 8. 通配符类型
