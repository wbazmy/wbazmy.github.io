---
layout: post
title: 并发基础
date: 2021-11-01
tags: JavaSE基础
---
## 1. 多线程概念
多线程是一个程序同时执行多个任务。每一个任务称为一个线程。  
进程拥有自己的一套变量，而线程则共享数据。线程间通信更容易且线程更加轻量级。  
线程允许用户保持对程序的控制权，而不是一直被一个程序阻塞。如果需要执行一个比较耗时的任务，应当并发地运行任务。  
在一个单独的线程中执行任务的步骤：
1. 将任务代码移到实现了Runnable接口的类的run方法中。该接口只有一个方法。Runnable r=()->{  };
2. 由Runnable创建一个Thread对象：Thread t=new Thread(r);
3. 启动线程：t.start();

另一种创建线程的方法：

```java
class myThread extends Thread
{
    public void run()
    {
        ...
    }
}
Thread t=new myThread();
t.start();
```

不推荐这种方法，因为应将运行机制与并行运行的任务解耦合。  
不要使用run方法，run和start的区别：
1. 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体中的代码执行完毕而直接继续执行后续的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里的run()方法 称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。
2. run()方法只是类的一个普通方法而已，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。  

不能多次启动一个线程：  
在start方法进来后就会判断线程的状态，如果不是初始态状态就会抛出异常，所以第二次执行就会报错，因为线程的状态已经发生改变。new了一个thread就进入初始态，调用start进入就绪态。
## 2. 中断线程
![](/images/JavaSE/thread.jfif)

当线程run方法执行完方法体最后一条语句后并经由return语句返回时，或出现了方法体重没有捕获的异常时，线程将终止。stop也可以终止线程，但已被弃用。  
没有可以强制终止线程的方法，interrupt可以用来请求终止线程。对一个线程调用interrupt方法时，线程的中断状态将被置位。每个线程都应一直检查状态位以判断线程是否被中断。  
要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法：

```java
while(!Thread.currentThread.isInterrupted()&&...)
{
    ...
}
```

但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或wait) 上调用interrupt方法时，阻塞调用将会被Interrupted Exception异常中断。  
中断一个线程不过是引起它的注意，被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式：

```java
Runnable r = () -> {
try
{
while (!Thread.currentThread().isInterrupted() && more work to do)
{
...
}
}
catch(InterruptedException e)
{
   // thread was interrupted during sleep or wait
}
finally
{
//cleanup, if required
}
// exiting the run method terminates the thread
};
```

如果在每次工作迭代之后都调用sleep方法（或者其他的可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法，它不会休眠。相反，它将清除这一状态并拋出InterruptedException。因此，如果你的循环调用sleep，不要检测中断状态。  
区分interrupted方法（静态方法）与isInterrupted方法（实例方法）：
![](/images/JavaSE/17.png)

## 3. 线程状态
线程有6种状态：
- New（新创建）
- Runnable（可运行）
- Blocked（被阻塞）
- Waiting（等待）
- Timed waiting(计时等待)
- Terminated（被终止）

可以使用getState方法查看线程的当前状态。6种状态：
### new
新创建线程。当用new操作符创建一个新线程时，如newThread(r)，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。
### Runnable
一旦调用start方法，线程就处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。一个线程开始运行后不一定一直在运行，抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。  
现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在手机中，一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权。多处理器机中每个处理器可运行一个线程。
### blocked和waiting
当线程被阻塞或等待时，它暂时不活动。它不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。有以下情况：
- 当一个线程试图获取一个内部的对象锁(而不是java.util.concurrent库中的锁)，而该锁被其他线程持有，则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
- 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。等待与阻塞有很大不同。join方法等待终止指定的进程。
- 有几个方法有一个超时参数。调用它们导致线程进入计时等待(timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join、Lock.tryLock以及Condition.await的计时版。

当一个线程被阻塞或等待时(或终止时)，另一个线程被调度为运行状态。当一个线程被重新激活(例如，因为超时期满或成功地获得了一个锁)，调度器检查它是否具有比当前运行线程更高的优先级。如果是，调度器从当前运行线程中挑选一个，剥夺其运行权，选择这个线程运行。  
![](/images/JavaSE/18.png)

### Terminated
线程有两种原因被终止：
1. run方法正常退出而自然死亡。
2. 因为一个没有捕获的异常终止了run方法而意外死亡。

## 4. 线程属性
线程优先级：每个线程有一个优先级。默认情况下，线程继承它父线程的优先级。setPriority(int)设置优先级。可以将优先级设置为在MIN_PRIORITY(在Thread类中定义为1) 与MAX_PRIORITY(定义为10)之间的任何值。NORM_PRIORITY被定义为5。  
线程调度器有机会选择新线程时总是会选择高优先级的线程。线程优先级高度依赖于系统。当虚拟机依赖于宿主机平台的线程实现机制时，Java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。  

```java
static void yield() //使当前执行线程暂时暂停运行（仍然处于可运行状态）。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。
```

守护线程：t.setDaemon(true)。设置守护线程，守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。  
## 5. 同步
多线程下可能有两个线程共享一个数据。根据各线程访问数据的次序，可能会产生错误的对象。这种情况叫竞争条件。  
例子：银行转账。accounts[to]+=amount;该操作不是原子操作。处理步骤：
1. 原余额加载到寄存器。
2. 增加amount。
3. 写回accounts[to]。

线程1执行完步骤1，2，然后被线程2剥夺运行权，执行步骤1，2，3，这时就出错了：
![](/images/JavaSE/19.png)

### 锁对象
有两种机制防止并发访问。synchronized关键字和ReentrantLock（用于临界区）类。ReentrantLock保护代码块：

```java
private Lock myLock=new ReentrantLock();
myLock.lock();
try{
    //临界区
}
finally{
    myLock.unlock(); //确保释放锁
}
```

这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程持有了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。  
每一个对象都有自己的锁对象，如果两个线程试图访问同一个Bank对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的Bank对象，每一个线程得到不同的锁对象，两个线程都不会发生阻塞。本该如此，因为线程在操纵不同的Bank实例的时候，线程之间不会相互影响。  
锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。  
例如，transfer方法调用getTotalBalance方法，这也会封锁bankLock对象，此时bankLock对象的持有计数为2。当getTotalBalance方法退出的时候，持有计数变回1。transfer方法退出的时候，持有计数变为0。线程释放锁。  
### 条件对象
线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。转账时，当余额不足时应等待另一个线程注入资金。但是这一线程已经占有了锁，所以需要条件对象。  
一个锁对象可以有一个或多个相关的条件对象。例：

```java
class Bank{
    private Condition sufficientfunds;
    public Bank{
        sufficientfunds=bankLock.newCondition();
    }
}
```

转账余额不足，调用：sufficientfunds.await(); 当前线程进入等待态并放弃锁。等待获得锁的线程和调用await方法的线程存在本质上的不同。一旦一个线程调用await方法，它进人该条件的等待集，直到别的线程调用这个条件上的signalAll方法。  
这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进人该对象。一旦锁成为可用的，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行。  
此时，线程应该再次测试该条件。由于无法确保该条件被满足，signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。  

```java
while(!(ok to proceed))  //await常用模版
condition.await();
```

当可能使对象的状态满足条件时调用signalAll方法。

```java
public void transfer(int from, int to, int amount)
{
     bankLock.lock();
try
{
while (accounts[from] < amount)
     sufficientFunds.await();
// transfer funds
     sufficientFunds.signalAll();
}
finally
{
    bankLock.unlock();
}
}
```

注意调用signalAll不会立即激活一个等待线程。它仅仅解除等待线程的等待态，以便这些线程可以在当前线程释放锁后，通过竞争实现对对象的访问。  
另一个方法signal，则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。可能导致死锁。