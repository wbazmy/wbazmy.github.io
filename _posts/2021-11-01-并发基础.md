---
layout: post
title: 并发基础
date: 2021-11-01
tags: JavaSE基础
---
## 1. 多线程概念
多线程是一个程序同时执行多个任务。每一个任务称为一个线程。  
进程拥有自己的一套变量，而线程则共享数据。线程间通信更容易且线程更加轻量级。  
线程允许用户保持对程序的控制权，而不是一直被一个程序阻塞。如果需要执行一个比较耗时的任务，应当并发地运行任务。  
在一个单独的线程中执行任务的步骤：
1. 将任务代码移到实现了Runnable接口的类的run方法中。该接口只有一个方法。Runnable r=()->{  };
2. 由Runnable创建一个Thread对象：Thread t=new Thread(r);
3. 启动线程：t.start();

另一种创建线程的方法：

```java
class myThread extends Thread
{
    public void run()
    {
        ...
    }
}
Thread t=new myThread();
t.start();
```

不推荐这种方法，因为应将运行机制与并行运行的任务解耦合。  
不要使用run方法，run和start的区别：
1. 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体中的代码执行完毕而直接继续执行后续的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里的run()方法 称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。
2. run()方法只是类的一个普通方法而已，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。  

不能多次启动一个线程：  
在start方法进来后就会判断线程的状态，如果不是初始态状态就会抛出异常，所以第二次执行就会报错，因为线程的状态已经发生改变。new了一个thread就进入初始态，调用start进入就绪态。
## 2. 中断线程
![](/images/JavaSE/thread.jfif)

当线程run方法执行完方法体最后一条语句后并经由return语句返回时，或出现了方法体重没有捕获的异常时，线程将终止。stop也可以终止线程，但已被弃用。  
没有可以强制终止线程的方法，interrupt可以用来请求终止线程。对一个线程调用interrupt方法时，线程的中断状态将被置位。每个线程都应一直检查状态位以判断线程是否被中断。  
要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法：

```java
while(!Thread.currentThread.isInterrupted()&&...)
{
    ...
}
```

但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或wait) 上调用interrupt方法时，阻塞调用将会被Interrupted Exception异常中断。  
中断一个线程不过是引起它的注意，被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式：

```java
Runnable r = () -> {
try
{
while (!Thread.currentThread().isInterrupted() && more work to do)
{
...
}
}
catch(InterruptedException e)
{
   // thread was interrupted during sleep or wait
}
finally
{
//cleanup, if required
}
// exiting the run method terminates the thread
};
```

如果在每次工作迭代之后都调用sleep方法（或者其他的可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法，它不会休眠。相反，它将清除这一状态并拋出InterruptedException。因此，如果你的循环调用sleep，不要检测中断状态。  
区分interrupted方法（静态方法）与isInterrupted方法（实例方法）：
![](/images/JavaSE/17.png)

## 3. 线程状态
线程有6种状态：
- New（新创建）
- Runnable（可运行）
- Blocked（被阻塞）
- Waiting（等待）
- Timed waiting(计时等待)
- Terminated（被终止）

可以使用getState方法查看线程的当前状态。6种状态：
### new
新创建线程。当用new操作符创建一个新线程时，如newThread(r)，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。
### Runnable
一旦调用start方法，线程就处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。一个线程开始运行后不一定一直在运行，抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。  
现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在手机中，一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权。多处理器机中每个处理器可运行一个线程。
### blocked和waiting
当线程被阻塞或等待时，它暂时不活动。它不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。有以下情况：
- 当一个线程试图获取一个内部的对象锁(而不是java.util.concurrent库中的锁)，而该锁被其他线程持有，则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
- 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。等待与阻塞有很大不同。join方法等待终止指定的进程。
- 有几个方法有一个超时参数。调用它们导致线程进入计时等待(timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join、Lock.tryLock以及Condition.await的计时版。

当一个线程被阻塞或等待时(或终止时)，另一个线程被调度为运行状态。当一个线程被重新激活(例如，因为超时期满或成功地获得了一个锁)，调度器检查它是否具有比当前运行线程更高的优先级。如果是，调度器从当前运行线程中挑选一个，剥夺其运行权，选择这个线程运行。  
![](/images/JavaSE/18.png)

### Terminated
线程有两种原因被终止：
1. run方法正常退出而自然死亡。
2. 因为一个没有捕获的异常终止了run方法而意外死亡。

## 4. 线程属性
线程优先级：每个线程有一个优先级。默认情况下，线程继承它父线程的优先级。setPriority(int)设置优先级。可以将优先级设置为在MIN_PRIORITY(在Thread类中定义为1) 与MAX_PRIORITY(定义为10)之间的任何值。NORM_PRIORITY被定义为5。  
线程调度器有机会选择新线程时总是会选择高优先级的线程。线程优先级高度依赖于系统。当虚拟机依赖于宿主机平台的线程实现机制时，Java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。  

```java
static void yield() //使当前执行线程暂时暂停运行（仍然处于可运行状态）。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。
```

守护线程：t.setDaemon(true)。设置守护线程，守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。  
## 5. 同步
多线程下可能有两个线程共享一个数据。根据各线程访问数据的次序，可能会产生错误的对象。这种情况叫竞争条件。  
例子：银行转账。accounts[to]+=amount;该操作不是原子操作。处理步骤：
1. 原余额加载到寄存器。
2. 增加amount。
3. 写回accounts[to]。

线程1执行完步骤1，2，然后被线程2剥夺运行权，执行步骤1，2，3，这时就出错了：
![](/images/JavaSE/19.png)

### 锁对象
有两种机制防止并发访问。synchronized关键字和ReentrantLock（用于临界区）类。ReentrantLock保护代码块：

```java
private Lock myLock=new ReentrantLock();
myLock.lock();
try{
    //临界区
}
finally{
    myLock.unlock(); //确保释放锁
}
```

这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程持有了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。  
每一个对象都有自己的锁对象，如果两个线程试图访问同一个Bank对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的Bank对象，每一个线程得到不同的锁对象，两个线程都不会发生阻塞。本该如此，因为线程在操纵不同的Bank实例的时候，线程之间不会相互影响。  
锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。  
例如，transfer方法调用getTotalBalance方法，这也会封锁bankLock对象，此时bankLock对象的持有计数为2。当getTotalBalance方法退出的时候，持有计数变回1。transfer方法退出的时候，持有计数变为0。线程释放锁。  
### 条件对象
线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。转账时，当余额不足时应等待另一个线程注入资金。但是这一线程已经占有了锁，所以需要条件对象。  
一个锁对象可以有一个或多个相关的条件对象。例：

```java
class Bank{
    private Condition sufficientfunds;
    public Bank{
        sufficientfunds=bankLock.newCondition();
    }
}
```

转账余额不足，调用：sufficientfunds.await(); 当前线程进入等待态并放弃锁。等待获得锁的线程和调用await方法的线程存在本质上的不同。一旦一个线程调用await方法，它进人该条件的等待集，直到别的线程调用这个条件上的signalAll方法。  
这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进人该对象。一旦锁成为可用的，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行。  
此时，线程应该再次测试该条件。由于无法确保该条件被满足，signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。  

```java
while(!(ok to proceed))  //await常用模版
condition.await();
```

当可能使对象的状态满足条件时调用signalAll方法。

```java
public void transfer(int from, int to, int amount)
{
     bankLock.lock();
try
{
while (accounts[from] < amount)
     sufficientFunds.await();
// transfer funds
     sufficientFunds.signalAll();
}
finally
{
     bankLock.unlock();
}
}
```

注意调用signalAll不会立即激活一个等待线程。它仅仅解除等待线程的等待态，以便这些线程可以在当前线程释放锁后，通过竞争实现对对象的访问。  
另一个方法signal，则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。可能导致死锁。
### synchronized关键字
有关锁和条件的总结：
- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被临界区的线程。
- 锁可以拥有一个或多个相关的条件对象。
- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

大多数情况下不需要锁的高度控制。synchronized关键字同样可以实现。Java每个对象都有一个内部锁，如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。要调用该方法，线程必须获得内部的对象锁。如：

```java
public synchronized void method()
{
    ...
}

public void transfer(int from, int to, int amount) { //相当于这样
        this.intrinsicLock.lock();
        try {
            accounts[from] -= amount;
            accounts[to] += amount;
        } finally {
            this.intrinsicLock.unlock();
        }
    }
```

内部对象锁有一个相关条件。wait方法将线程添加到等待集，notifyAll和notify解除线程的等待状态。  
synchronized可用于静态方法，如果调用这种方法，该方法获得相关的类对象的内部锁。如果Bank类有一个静态同步的方法，那么当该方法被调用时，Bankclass对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。  
### 同步阻塞
还有另外一种方法获得锁：

```java
synchronized(obj)
{
    //临界区
}
```

这样，线程就可以获得obj的锁。  
Volatile域：两层含义：
1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序。

每个线程都会有自己的工作内存，每次取值时都去工作内存取，但不能保证工作内存里（可能别的线程还没完成写操作）是最新的值，所以需要volatile关键字。  
使用volatile关键字的效果：
1. 使用volatile关键字会强制将修改的值立即写入主存；
2. 使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效，缓存行对应的内存地址发生改变）；
3. 由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次（注意是下一次读取时）读取变量stop的值时会去主存读取。

第二条的意思：  
当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。
必须保证对变量的操作是原子操作（读取和赋值）才能保证使用volatile关键字的程序在并发时能够正确执行。  
参考链接：[](https://www.cnblogs.com/dolphin0520/p/3920373.html)
要避免死锁的发生，Java没有任何方法可以避免或打破死锁现象。  
AtomicInteger类提供了方法incrementAndGet和decrementAndGet，它们分别以原子方式将一个整数自增或自减。AtomicReference是对普通类对象的封装。

```java
AtomicInteger n=new AtomicInteger(2);
int i=n.incrementAndGet();
System.out.println(i);
```

可以保证即使是多个线程并发地访问同一个实例，也会计算并返回正确的值。  
CAS（自旋锁）详解：compareAndSet。CAS指令在Intel CPU上称为CMPXCHG指令，它的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，如果不相等，则更新失败。这一比较并交换的操作是原子的，不可以被中断。初一看，CAS也包含了读取、比较 (这也是种操作)和写入这三个操作，和之前的i++并没有太大区别，但CAS是通过硬件命令保证了原子性，而i++没有，且硬件级别的原子性比i++这样高级语言的软件级别的运行速度要快地多。虽然CAS也包含了多个操作，但其运算是固定的(就是个比较)，这样的锁定性能开销很小。  
从内存领域来说这是乐观锁，因为它在对共享变量更新之前会先比较当前值是否与更新前的值一致，如果是，则更新，如果不是，则无限循环执行(称为自旋)，直到当前值与更新前的值一致为止，才执行更新。  
CAS可以用来实现自旋锁：

```java
public class SpinLockTest {

    private AtomicBoolean available = new AtomicBoolean(false);

    public void lock(){

        // 循环检测尝试获取锁
        while (!tryLock()){
            // doSomething...
        }

    }

    public boolean tryLock(){
        // 尝试获取锁，成功返回true，失败返回false
        return available.compareAndSet(false,true);
    }

    public void unLock(){
        if(!available.compareAndSet(true,false)){
            throw new RuntimeException("释放锁失败");
        }
    }

}
```

大量的自旋锁会降低性能。所以可以使用LongAdder类。它将原变量分为多个变量，让线程去竞争多个资源，使用LongAdder时，内部维护了多个Cell变量，每个Cell里面有一个初始值为0的long型变量，这样同时争取一个变量的线程就变少了，而是分散成对多个变量的竞争，减少了失败次数。如果竞争某个Cell变量失败，它不会一直在这个Cell变量上自旋CAS重试，而是尝试在其他的Cell变量上进行CAS尝试，这个改变增加了当前线程重试CAS成功的可能性。最后，在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的。  
LongAccumulator功能更强大，可以进行任意的累加操作。在构造器中，可以提供这个操作以及它的零元素。要加人新的值，可以调用accumulate。调用get来获得当前值。例：

```java
LongAccumulator adder=new LongAccumulator(Lont::sum,0);
adder.accumulate(value);
```

在内部，这个累加器包含变量a1, a2 ，…，an。每个变量初始化为零元素（这个例子中零元素为0)。调用accumulate并提供值v 时，其中一个变量会以原子方式更新为ai= ai op v。op为提供的操作符。get的结果是a1 op a2 op...an。操作需满足结合律和交换律。

