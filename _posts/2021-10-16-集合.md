---
layout: post
title: 集合
date: 2021-10-16
tags: JavaSE基础
---
## 1. Java集合框架
Java集合类库用来实现各种数据结构。Java集合类库将接口与实现分离。如队列接口如下：

```java
public interface Queue<E>{
    void add(E element);
    E remove();
    int size();
    ...
}
```

接口并没有说明队列是如何实现的，具体实现由实现了Queue接口的类表示。例：

```java
public CircularArrayQueue<E> implements Queue<E>
{
    private int head;
    private int tail;
    CircularArrayQueue(int capacity){...}
    public void add(E element){...}
    public E remove(){...}
    public int size() {...}

    private E[] elements;
}
```

当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。只有构建集合对象时才使用具体的类。可以使用接口类型存放集合的引用。  
一旦改变了想法就可以使用另一种不同的实现。  
### Collection接口
集合类的基本接口是Collection接口。这个接口有两个基本方法：

```java
public interface Collection<E>
{
    boolean add(E element);
    Iterator<E> iterator();
}
```

除了这两个方法还有其他几个方法。  
- add向集合添加元素，如果添加元素确实改变了集合就返回true，集合没有发生变化返回false。
- iterator用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象依次访问集合元素。

### 迭代器
Iterator接口有4个方法：

```java
public interface Iterator<E>
{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action);
}
```

next返回下一个元素并指向下一个元素。如果到集合末尾会抛出异常。例：

```java
Collection<String> c=...;
Iterator<String> iter=c.iterator();
while(iter.hasNext())
{
    String e=iter.next();
}

for(String e:c)  //自动翻译为带迭代器的循环
{
    ...
}
```

for each循环可以与任何实现了Iterable接口的对象一起工作。这个接口只包含一个抽象方法：

```java
public interface Iterable<E>
{
    Iterator<E> iterator();
}
```

Collection接口实现了Iterable接口，任何集合都可使用for each循环。  
forEachRemaining使用一个lambda表达式，将对迭代器每一个元素调用lambda表达式。例：

```java
iterator.forEachRemaining(element->...);
```

元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而，如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。  
Java迭代器没有索引，查找一个元素的唯一方式是调用next。Java迭代器位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。  
![](/images/JavaSE/5.png)

remove方法会删除上次调用next方法时返回的元素。  
如果调用remove前没有调用next是不合法的，将抛出异常。  
Collection常用方法：

```java
int size()
boolean isEmpty()
boolean contains(Object obj) //集合中包含与obj相等的对象返回true
void clear()
Object[] toArray()
```

### 集合框架中的接口
接口示意图：  
![](/images/JavaSE/6.png)

集合两个基本接口：Collection和Map。在映射包中用put方法插入键/值对：

```java
V put(K key, V value)
V get(K key) //从映射中取值
```

List是有序集合，元素会增加到容器中的特定位置。有两种方式访问元素：迭代器访问，随机访问（使用整数索引）。List接口用于随机访问的方法：

```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

ListIterator接口是Iterator子接口，定义了一个方法用于在迭代器位置前增加一个元素：

```java
void add(E element)
```

实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。与之不同，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。    
Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集（set)的add方法不允许增加重复的元素。要适当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。  
SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。  
接口NavigableSet和NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法。  

## 2. 具体的集合
除了以Map结尾的类之外，其他类都实现了Collection接口，而以Map结尾的类实现了Map接口。  
![](/images/JavaSE/7.png)
![](/images/JavaSE/9.png)

### 链表
ArrayList即数组列表，数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置上插入一个元素也是如此。  
LinkedList即链表列表，但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java程序设计语言中，所有链表实际上都是双向链接的(doubly linked)，即每个结点还存放着指向前驱结点的引用。在链表中间插入或删除一个元素很容易，但随机读取很慢。  
![](/images/JavaSE/8.png)

链表与泛型集合之间有一个重要的区别。链表是一个有序集合(ordered collection), 每个对象的位置十分重要。LinkedList.add方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。例如，下一节将要讨论的集(set) 类型，其中的元素完全无序。因此，在Iterator接口中就没有add方法。相反地，集合类库提供了子接口ListIterator，其中包含add方法。

```java
void add(E element)
```

ListIterator接口有两个方法用来反向遍历链表：

```java
E previous()
boolean hasPrevious()
```

previous返回越过的对象。  
LinkedList类的listIterator方法返回一个实现了ListIterator接口的迭代器对象。

```java
ListIterator<String> iter=staff.listIterator();
```

ListIterator的add方法将在迭代器位置之前添加一个新对象。  
当用一个刚刚由Iterator方法返回，并且指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(即hasNext返回false)，添加的元素将变成列表的新表尾。  
注：add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态。  
set方法用一个新元素取代调用next或previous方法返回的上一个元素。  
如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个
ConcurrentModificationException异常。  
功能总结：可以使用ListIterator类从前后两个方向遍历链表中的元素，并可以添加、删除元素。  
List常用方法：

```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
int indexOf(Object element)  //返回与指定元素相等的元素在列表中第一次出现的位置，没有返回-1
int lastIndexOf(Object element)  //同上
ListIterator<E> listIterator(int index) //返回一个迭代器，指向索引为index的元素前面的位置
```

ListIterator：

```java
int nextIndex() //返回下一次调用next方法时将返回的元素索引
int previousIndex() //同上
```

LinkedList:

```java
void addFirst(E) //添加到头部
void addLast(E)  //尾部
getFirst
getLast
removeFirst
removeLast
```

### 数组列表
ArrayList封装了一个动态再分配的对象数组。适合随机访问，ArrayList也实现了List接口。  
### 散列集
在链表和数组查找一个指定元素非常慢。如果不在意元素顺序，可以有几种能够快速査找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。  
散列表可以快速查找元素，散列表为每个对象计算一个整数，称为散列码（hashcode)。散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。散列码由类的hasCode方法产生。  
如果自定义类，就要负责实现这个类的hashCode方法。自己实现的hashCode方法应该与equals方法兼容，即如果a.equals(b)为true, a与b必须具有相同的散列码。  
hashCode方法：根据对象的内容计算出一个整数值，HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的。与equals方法的关系：
1. 如果两个对象equals相等，那么这两个对象的HashCode一定也相同。
2. 如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置。
3. 如果重写了equals方法，则也应该重写hashCode方法。

在Java中，散列表用链表数组实现。每个列表被称为桶(bucket)。要想査找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。如果某个对象的散列码为76268，并且有128个桶，对象应该保存在第108号桶中(76268除以128余108)。如果出现散列冲突就会将新对象与桶中对象比较看是否已存在。  
![](/images/JavaSE/10.png)

如果散列表太慢就会再散列，如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。  
散列表用于实现set类型，set是没有重复元素的元素集合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。  
Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。它只在某个桶中査找元素，而不必查看集合中的所有元素。  
散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用HashSet。  
### 树集
TreeSet类与散列集相似。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后（正序）的顺序呈现。排序用红黑树实现。将元素添加到树中比添加到散列表慢。  
要使用树集就必须能够比较元素，即实现Comparable接口或者在构造集时提供一个比较器（实现了Comparator接口的实例）。TreeSet实现了SortedSet和NavigableSet接口（用于定位元素和反向遍历）。  
SortedSet方法：

```java
Comparator<? super E> comparator() //返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null
E first() //返回有序集最小元素
E last()
```

NavigableSet方法：

```java
E higher(E value)
E lower(E value) //返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null
E ceiling(E value)
E floor(E value) //返回大于等于vaiue 的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null
Iterator<E> descendingIterator() //返回一个按照递减顺序遍历集中元素的迭代器
```

### 队列
队列可以在尾部添加元素，头部删除元素。有两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元
素。但不支持在队列中间添加元素。Deque接口，由ArrayDeque和LinkedList类实现。
Queue方法：

```java
boolean add(E element) 
boolean offer(E element) //如果队列没有满，将给定的元素添加到这个双端队列的尾部并返回true。如果队列满了，第一个方法将拋出一个IllegalStateException，而第二个方法返回false
E remove()
E poll() //假如队列不空，删除并返回这个队列头部的元素。如果队列是空的，第一个方法抛出NoSuchElementException，而第二个方法返回null
E element()
E peek() //如果队列不空，返回这个队列头部的元素，但不删除。如果队列空，第一个方法将拋出一个NoSuchElementException，而第二个方法返回null
```

Deque：
![](/images/JavaSE/11.png)

### 优先级队列
优先级队列(priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。优先级队列使用堆实现。优先级队列。与TreeSet一样，要么元素类实现了Comparable接口，要么提供比较器。PriorityQueue。  
## 3. 映射
map（映射）用来存放键/值对。映射有两个实现：HashMap，TreeMap。这两个类都实现了Map接口。  
散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。散列比树快，如果不需要按照排列顺序访问键，就最好选择散列。  
通过提供键来返回值：

```java
Map<Integer, student> class1 = new HashMap<>();
class1.put(1, s1);
class1.put(5, s2);
class1.put(6, s3);
student s4=class1.get(5);
s4=getOrDefault(10,s1); //键存在返回相关联的值，不存在则返回s1
```

没有与键对应的信息则返回null。  
对同一个键调用两次put方法，第二个值会取代第一个值。remove方法会删除给定键对应的元素。size返回元素数。  
迭代处理map，最容易的方法是使用forEach方法，可以提供一个接收键和值的lambda表达式。map的每一项会调用这个表达式。

```java
class1.forEach((k,v)-> System.out.println(k+" "+v.getAvrscore()));
```

TreeMap（与TreeSet一样要求）根据键对元素排序：

```java
Map<Integer, student> class1 = new TreeMap<>();
class1.put(10, s1);
class1.put(5, s2);
class1.put(6, s3);
student s4=class1.get(5);
class1.forEach((k,v)-> System.out.println(k+" "+v.getAvrscore()));
```

映射视图：
![](/images/JavaSE/12.png)
### 弱散列映射
如果某个值的键不再使用，那么再也不能有任何途径引用这个值的对象。但是由于映射对象是活动的，所以不能删除这个值。可以用WeakHashMap完成这件事。当对键的唯一引用来自散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键/值对。WeakHashMap使用弱引用(weak references) 保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用，并
且已经被收集起来。于是，WeakHashMap将删除对应的条目。  
### 链接散列集与映射
LinkedHashSet和LinkedHashMap类会记住插入元素项的顺序，这样会避免散列表中的项访问时是随机的。当条目插入表中时，会并入到双向链表中。  
![](/images/JavaSE/13.png)

```java
package package1;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @author Zhang Yang
 * @description 集合测试
 * @date 2021/10/23 - 17:01
 */
public class CollectionTest {
    public static void main(String[] args) {
        Map<String, student> lh = new LinkedHashMap<>();
        lh.put("12", new student("zy"));
        lh.put("13", new student("zy1"));
        lh.put("14", new student("zy2"));
        Iterator<String> it1 = lh.keySet().iterator();
        while (it1.hasNext()) {
            String s = it1.next();
            System.out.println(s);  //会按插入顺序输出
        }
        Iterator<student> it2 = lh.values().iterator();
        while (it2.hasNext()) {
            System.out.println(it2.next().getName());
        }
    }
}
```

若想使用访问顺序迭代可调用：

```java
LinkedHashMap<K,V>(15,loadFactor,true);
```

### 枚举集与映射
EnumSet是一个枚举类型元素集的高效实现。EnumSet类没有公共的构造器。可以使用静态工厂方法构造这个集：
![](/images/JavaSE/14.png)

EnumMap是键类型为枚举类型的映射：

```java
EnumMap<Weekday,student> e1=new EnumMap<>(Weekday.class);
```

IdentityHashMap键的散列值不是用hashCode 函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用==,，而不使用equals。  
也就是说，不同的键对象，即使内容相同，也被视为是不同的对象。在实现对象遍历算法（如对象串行化）时，这个类非常有用， 可以用来跟踪每个对象的遍历状况。  
## 4. 视图与包装器










