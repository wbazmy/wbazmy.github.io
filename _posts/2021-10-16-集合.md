---
layout: post
title: 集合
date: 2021-10-16
tags: JavaSE基础
---
## 1. Java集合框架
Java集合类库用来实现各种数据结构。Java集合类库将接口与实现分离。如队列接口如下：

```java
public interface Queue<E>{
    void add(E element);
    E remove();
    int size();
    ...
}
```

接口并没有说明队列是如何实现的，具体实现由实现了Queue接口的类表示。例：

```java
public CircularArrayQueue<E> implements Queue<E>
{
    private int head;
    private int tail;
    CircularArrayQueue(int capacity){...}
    public void add(E element){...}
    public E remove(){...}
    public int size() {...}

    private E[] elements;
}
```

当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。只有构建集合对象时才使用具体的类。可以使用接口类型存放集合的引用。  
一旦改变了想法就可以使用另一种不同的实现。  
### Collection接口
集合类的基本接口是Collection接口。这个接口有两个基本方法：

```java
public interface Collection<E>
{
    boolean add(E element);
    Iterator<E> iterator();
}
```

除了这两个方法还有其他几个方法。  
- add向集合添加元素，如果添加元素确实改变了集合就返回true，集合没有发生变化返回false。
- iterator用于返回一个实现了Iterator接口的对象。可以用这个迭代器对象依次访问集合元素。
### 迭代器
Iterator接口有4个方法：

```java
public interface Iterator<E>
{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action);
}
```

next返回下一个元素并指向下一个元素。如果到集合末尾会抛出异常。例：

```java
Collection<String> c=...;
Iterator<String> iter=c.iterator();
while(iter.hasNext())
{
    String e=iter.next();
}

for(String e:c)  //自动翻译为带迭代器的循环
{
    ...
}
```

for each循环可以与任何实现了Iterable接口的对象一起工作。这个接口只包含一个抽象方法：

```java
public interface Iterable<E>
{
    Iterator<E> iterator();
}
```

Collection接口实现了Iterable接口，任何集合都可使用for each循环。  
forEachRemaining使用一个lambda表达式，将对迭代器每一个元素调用lambda表达式。例：

```java
iterator.forEachRemaining(element->...);
```

元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而，如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。  
Java迭代器没有索引，查找一个元素的唯一方式是调用next。Java迭代器位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。  
![](/images/JavaSE/5.png)

remove方法会删除上次调用next方法时返回的元素。  
如果调用remove前没有调用next是不合法的，将抛出异常。  
Collection常用方法：

```java
int size()
boolean isEmpty()
boolean contains(Object obj) //集合中包含与obj相等的对象返回true
void clear()
Object[] toArray()
```

### 集合框架中的接口
接口示意图：  
![](/images/JavaSE/6.png)

集合两个基本接口：Collection和Map。在映射包中用put方法插入键/值对：

```java
V put(K key, V value)
V get(K key) //从映射中取值
```

List是有序集合，元素会增加到容器中的特定位置。有两种方式访问元素：迭代器访问，随机访问（使用整数索引）。List接口用于随机访问的方法：

```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

ListIterator接口是Iterator子接口，定义了一个方法用于在迭代器位置前增加一个元素：

```java
void add(E element)
```

实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。与之不同，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历。    
Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集（set)的add方法不允许增加重复的元素。要适当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。  
SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。  
接口NavigableSet和NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法。  

## 2. 具体的集合
除了以Map结尾的类之外，其他类都实现了Collection接口，而以Map结尾的类实现了Map接口。  
![](/images/JavaSE/7.png)
![](/images/JavaSE/9.png)

### 链表
ArrayList即数组列表，数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置上插入一个元素也是如此。  
LinkedList即链表列表，但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java程序设计语言中，所有链表实际上都是双向链接的(doubly linked)，即每个结点还存放着指向前驱结点的引用。在链表中间插入或删除一个元素很容易，但随机读取很慢。  
![](/images/JavaSE/8.png)

链表与泛型集合之间有一个重要的区别。链表是一个有序集合(ordered collection), 每个对象的位置十分重要。LinkedList.add方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。例如，下一节将要讨论的集(set) 类型，其中的元素完全无序。因此，在Iterator接口中就没有add方法。相反地，集合类库提供了子接口ListIterator，其中包含add方法。

```java
void add(E element)
```

ListIterator接口有两个方法用来反向遍历链表：

```java
E previous()
boolean hasPrevious()
```

previous返回越过的对象。  
LinkedList类的listIterator方法返回一个实现了ListIterator接口的迭代器对象。

```java
ListIterator<String> iter=staff.listIterator();
```

ListIterator的add方法将在迭代器位置之前添加一个新对象。  
当用一个刚刚由Iterator方法返回，并且指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(即hasNext返回false)，添加的元素将变成列表的新表尾。  
注：add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态。  
set方法用一个新元素取代调用next或previous方法返回的上一个元素。  
如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个
ConcurrentModificationException异常。  
功能总结：可以使用ListIterator类从前后两个方向遍历链表中的元素，并可以添加、删除元素。  
List常用方法：

```java
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
int indexOf(Object element)  //返回与指定元素相等的元素在列表中第一次出现的位置，没有返回-1
int lastIndexOf(Object element)  //同上
ListIterator<E> listIterator(int index) //返回一个迭代器，指向索引为index的元素前面的位置
```

ListIterator：

```java
int nextIndex() //返回下一次调用next方法时将返回的元素索引
int previousIndex() //同上
```

LinkedList:

```java
void addFirst(E) //添加到头部
void addLast(E)  //尾部
getFirst
getLast
removeFirst
removeLast
```













